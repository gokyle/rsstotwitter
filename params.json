{"body":"# Overview\r\n`rsstotwitter` is an application that posts stories from \r\nan RSS feed to Twitter.\r\n\r\nThere is an experimental web interface (which by default runs on port 8080)\r\nwhere I am learning how to do that type of work in Go.\r\n\r\n## Background\r\n`rsstotwitter` started out as a specific application to post news stories\r\nfrom [lobste.rs](https://lobste.rs) to [Twitter](https://twitter.com/lobsternews).\r\n\r\nThe first version was written in 92 source lines of code in Python, and is\r\na fairly basic system based on SQLite. I've been learning\r\n[Go](http://www.golang.org) lately, and needed a project to work on,\r\npreferably writing some type of webapp as that is an area I have no experience\r\nin. Ergo, the decision to rewrite [lobsterpie](https://kisom.github.com/lobsterpie)\r\nin Go.\r\n\r\n## Architecture\r\n`rsstotwitter` is comprised of two main components, `bot` (the backend) and\r\n`frontend`. The backend employs a worker pool using goroutines and channels,\r\nwhile the frontend simply displays the last time the bot updated.\r\n\r\nThe backend starts up the worker pool, which communicate via a channel for\r\nnew stories. This channel is written to by the RSS feed parser, which is in\r\na separate goroutine. When the RSS feed is updated, it reads the entries,\r\nconverts them to the internal data structure that represents a story, and\r\nwrites that to the channel. The next available worker picks it up, checks\r\nwhether the story has already been posted, and if not, posts the story to\r\nTwitter and marks the story as read in the database. Reading from a channel\r\nblocks, so each worker essentially sleeps while waiting for new stories.\r\n\r\n## Deployment\r\nThe code is designed to be deployable to [Heroku](https://www.heroku.com),\r\nand uses a [Postgres](http://www.postgres.org) database that is configurable\r\nfrom the environment. As the application effectively only has one user, the \r\ntransaction cost isn't an issue.\r\n\r\nI had originally wanted to use [Redis](https://www.redis.io) as the datastore,\r\nbut Heroku's Redis addon costs money. This app generates no revenue, so I\r\ndidn't want to end up paying for keeping it running; Redis also requires\r\nan SSL tunnel in order to communicate securely with remote datastores which\r\nwould end up being a hassle to setup. I already had a VPS set up with Postgres,\r\nso I ended up just using that. It is overkill, as the table merely stores the\r\nguid of the story, but the infrastructure was already in place, and therefore\r\nthe decision to base this on Postgres.\r\n\r\nSee also the `DEPLOYMENT` section.\r\n\r\n## Setting Up\r\nYou will need to run `tools/customise.sh` in the project root to properly\r\nset up imports.\r\n\r\n# Deployment Instructions\r\n\r\n## Environment Variables\r\nThe `environ.sh` file contains a template for the relevant environment \r\nvariables. You should copy it to a new file to ensure secrets don't leak\r\ninto your Git repository.\r\n\r\nThese variables are:\r\n\r\n### Database\r\n* `PG_DBNAME`\r\n* `PG_USER`\r\n* `PG_PASS`\r\n* `PG_HOST`\r\n* `PG_PORT`\r\n* `PG_SSLMODE`\r\n\r\n### Twitter\r\nCreate an application on [Twitter](https://dev.twitter.com) and generate the\r\nOAuth keys from the web interface. Copy those keys into the config script.\r\nThese correspond to the consumer key, consumer secret, access token, and\r\naccess secret.\r\n* `TW_CKEY`\r\n* `TW_CSEC`\r\n* `TW_ATOK`\r\n* `TW_ASEC`\r\n\r\n### Feed\r\n* `RSS_FEED` should specify the RSS feed to follow.\r\n\r\n### Optional: Mail\r\n* `MAIL_SERVER`\r\n* `MAIL_USER`\r\n* `MAIL_PASS`\r\n* `MAIL_ADDRESS`\r\n* `MAIL_PORT`\r\n* `MAIL_TO`\r\n\r\n### Optional: Pushover\r\nSee the [Pushover](https://www.pushover.net) to register an application and\r\nget a user key.\r\n* `PO_APIKEY`\r\n* `PO_USER`\r\n\r\n## Heroku\r\n`rsstotwitter` uses the Heroku Go buildpack, which so far runs pretty smoothly;\r\nsetting up the deployment to Heroku was pretty easy and very\r\n[straightforward](https://gist.github.com/299535bbf56bf3016cba).\r\n\r\nYou'll need the [Heroku toolbelt](https://toolbelt.heroku.com/), particularly\r\nif you want to use the environment setup shell script. There is an included\r\n`heroku_setup.sh` script to automate the process.\r\n\r\n## Database\r\nThe database expects a table `posted` with two columns: `guid` and `posted`.\r\n\r\nExample database setup code:\r\n```sql\r\ncreate role ${PG_USER}\r\n        login \r\n        password '${PG_PASS}';\r\ncreate database ${PG_DBNAME} \r\n                ENCODING = 'UTF8' \r\n                LC_COLLATE = 'en_US.UTF-8' \r\n                LC_CTYPE = 'en_US.UTF-8' \r\n                template = template0;\r\nALTER DATABASE ${PG_DBNAME} OWNER TO ${PG_USER} ;\r\n\\connect ${PG_DBNAME}\r\ncreate table posted (guid text unique not null, \r\n                     posted boolean default false not null);\r\ncreate index posted_idx on posted;\r\n```\r\n\r\nThere are two example SQL files in the `dbase` directory.\r\n","name":"rsstotwitter","tagline":"Post stories from RSS to Twitter.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}